/*
 * generated by Xtext 2.24.0
 */
package uk.kcl.pgt.mdd.cw.generator

import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.emf.common.util.EList
import uk.kcl.pgt.mdd.cw.game.Game
import uk.kcl.pgt.mdd.cw.game.VarDecl
import uk.kcl.pgt.mdd.cw.game.AnimBlock
import uk.kcl.pgt.mdd.cw.game.ObjDecl
import uk.kcl.pgt.mdd.cw.game.EventBlock
import uk.kcl.pgt.mdd.cw.game.IfStmt
import uk.kcl.pgt.mdd.cw.game.WhileStmt
import uk.kcl.pgt.mdd.cw.game.ForStmt
import uk.kcl.pgt.mdd.cw.game.EndStmt
import uk.kcl.pgt.mdd.cw.game.AssStmt
import uk.kcl.pgt.mdd.cw.game.Var
import uk.kcl.pgt.mdd.cw.game.AttrAss
import uk.kcl.pgt.mdd.cw.game.IntLiteral
import uk.kcl.pgt.mdd.cw.game.Expression
import uk.kcl.pgt.mdd.cw.game.UnaryOperation
import uk.kcl.pgt.mdd.cw.game.Operation
import uk.kcl.pgt.mdd.cw.game.StmtBlock

/*
 * generated by Xtext 2.24.0
 */





/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GameGenerator extends AbstractGenerator {
 MGPLMapperUtil util = new MGPLMapperUtil

 override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
  val game = resource.allContents.head as Game
  copyUtilCode(fsa)
  
  val htmlCode = generateIndexHtml(game)
  fsa.generateFile("page.html", htmlCode)
  
  val jsCode = generateGameJs(game)
  fsa.generateFile("war.js", jsCode)
 }
 
 def generateIndexHtml(Game game) {
  '''
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link rel="preconnect" href="https://fonts.gstatic.com">
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&display=swap" rel="stylesheet">
      <script type="text/javascript" src="util.js"></script>
  
      <title>«game.name»</title>
      <script type="text/javascript" src="war.js"></script>
  </head>
  
  <body style="margin: 0;background-color: #f79586;color: #fefefe;font-family:"Times New Roman",Georgia,Serif;">
      <div style="text-align: center;" id="container">
          <h2 style="text-transform: uppercase;">«game.name»</h2>
          <canvas id="gameCanvas" width="«findAttribute(game.attrAssList.attrAss, "width")»" height="«findAttribute(game.attrAssList.attrAss, "height")»"></canvas>
      </div>
  </body>
  
  </html>
  '''
 }
 
 def generateGameJs(Game game) {
  '''
  // Global game-framework vars
  var canvas;
  var context;
  
  var «game.name» = { «generateAttributeAssignments(game.attrAssList.attrAss)» }
  
  // Global variables
  «FOR d : game.decl.filter[it instanceof VarDecl].map[it as VarDecl]»
   var «d.name»«IF d.expr !== null» = «util.resolveExpression(d.expr)»«ENDIF»;
  «ENDFOR»
  
  // Animations
  «FOR animation : game.functions.filter[it instanceof AnimBlock].map[it as AnimBlock]»
  function «animation.name»(«animation.objName») {
   «generateStatements(animation.stmtBlock)»
  }
  
  «ENDFOR»
  «FOR d : game.decl.filter[it instanceof ObjDecl].map[it as ObjDecl]»
   «IF d.arrSize === 0»
    var «d.name» = {«generateAttributeAssignments(d.attrAssList.attrAss)», type: «util.mapObjType(d.type)»«IF findAttribute(d.attrAssList.attrAss, "visible") == "undefined"», visible: 1«ENDIF»};
   «ELSE»
    var «d.name» = [«generateDefaultArrayDecl(d)»];
   «ENDIF»
  «ENDFOR»
  
  var gameObjs = [«generateObjectList(game.decl.filter[it instanceof ObjDecl].map[it as ObjDecl])»]
  
  // KeyEvents
  «FOR event : game.functions.filter[it instanceof EventBlock].map[it as EventBlock]»
  function «event.key»() {
   «generateStatements(event.stmtBlock)»
  }
  
  «ENDFOR»
  // KeyMap to work with in the input loop
  var keyMap = new Map();
  «FOR event : game.functions.filter[it instanceof EventBlock].map[it as EventBlock]»
  keyMap.set('«util.mapKey(event.key)»', { keydown: false, onDown: «event.key» });
  «ENDFOR»
  
  «generateStatements(game.initBlock)»
  
  window.onload = function(){
   canvas = document.getElementById('gameCanvas');
   context = canvas.getContext('2d');
     
   window.addEventListener('keydown', (e) => {
    if (keyMap.has(e.key)) {
     keyMap.get(e.key).keydown = true;
    }
   }, true);
     
   window.addEventListener('keyup', (e) => {
    if (keyMap.has(e.key)) {
     keyMap.get(e.key).keydown = false;
    }
   }, true);
     
   window.requestAnimationFrame(gameLoop);
   window.requestAnimationFrame(inputLoop);
  }
  
  function gameLoop() {
      // blank fill background
      context.fillStyle = 'white';
      context.fillRect(0, 0, canvas.width, canvas.height);
  
      // Animate and draw objects
      gameObjs.forEach(obj => {
       if (Array.isArray(obj)) {
        obj.forEach(x => {
         if (x.anim) {
          x.anim(x)
         }
        })
       } else {
        if (obj.anim) {
         obj.anim(obj);
        }
       }
       draw(obj);
      });
  
      // request next animation frame
      window.setTimeout(() => window.requestAnimationFrame(gameLoop), 1000 / «findAttribute(game.attrAssList.attrAss, "speed")»);
  }
  
  function inputLoop() {
      // Execute input updates
      keyMap.forEach((value, key) => {
          if (value.keydown) {
              value.onDown();
          }
      });
  
      // blank fill background
      context.fillStyle = 'white';
      context.fillRect(0, 0, canvas.width, canvas.height);
  
      // Animate and draw objects
      gameObjs.forEach(obj => {
          draw(obj);
      });
  
      window.setTimeout(() => window.requestAnimationFrame(inputLoop), 1000 / «findAttribute(game.attrAssList.attrAss, "speed")»);
  }
  '''
 }
 
 def generateDefaultArrayDecl(ObjDecl decl) {
  var result = ""
  for(var i = 0; i < decl.arrSize; i++) {
   result += '''createDefaultGameObj(«util.mapObjType(decl.type)»)'''
   if(i != decl.arrSize -1) {
    result += ", "
   }
  }
  return result
 }
 
 def String generateStatements(StmtBlock block) {
  if(block === null) {
   return ""
  }
  var result = ""
  for(stmt : block.statements) {
   if(stmt instanceof IfStmt) {
    var ifStmt = stmt as IfStmt
    result += '''
    if(«util.resolveExpression(ifStmt.condition)») {
     «generateStatements(ifStmt.consequence)»
    } «IF ifStmt.alternative !== null» else {
     «generateStatements(ifStmt.alternative)»
    } «ENDIF»
    '''
   } else if(stmt instanceof ForStmt) {
    var forStmt = stmt as ForStmt
    result += '''
    for(«generateAssignmentStatement(forStmt.initStmt)»; «util.resolveExpression(forStmt.endCondition)»; «generateAssignmentStatement(forStmt.loopStmt)») {
     «generateStatements(forStmt.stmtBlock)»
    }
    '''
   } 
   else if(stmt instanceof WhileStmt) {
       var whileStmt = stmt as WhileStmt
       result += '''
       while(«util.resolveExpression(whileStmt.whileCondition)») {
        «generateStatements(whileStmt.stmtBlock)»
       }
       '''
      }
      else if(stmt instanceof EndStmt){
      	result+='''
      	alert('game over!!!');
      	'''
      }
      else if(stmt instanceof AssStmt) {
    result += generateAssignmentStatement(stmt as AssStmt) + ";\n"
   }
  }
  return result
 }
 
 def generateAssignmentStatement(AssStmt assignment) {
  '''«generateVarName(assignment.^var)» = «util.resolveExpression(assignment.assignment)»'''
 }
 
 def generateObjectList(Iterable<ObjDecl> itr) {
  var result = ""
  for(var i = 0; i < itr.size; i++) {
   result += itr.get(i).name
   if(i != itr.size - 1) {
    result += ", "
   }
  }
  return result;
 }
 
 def generateVarName(Var v) {
  '''«v.name»«IF v.varArray !== null»[«util.resolveExpression(v.varArray.indexExpr)»]«ENDIF»«IF v.varProp !== null».«util.mapPropertyName(v.varProp.extId)»«ENDIF»'''
 }
 
 
 
 def generateAttributeAssignments(EList<AttrAss> assignments) {
  var result = ""
  for(var i = 0; i < assignments.size; i++) {
   result += generateAttributeAssignment(assignments.get(i))
   if(i != assignments.size - 1) {
    result += ", "
   }
  }
  return result;
 }
 
 def generateAttributeAssignment(AttrAss assignment) {
  '''«util.mapPropertyName(assignment.name)»: «util.resolveExpression(assignment.expr)»'''
 }
 
 def findAttribute(EList<AttrAss> assignments, String... fields) {
  var AttrAss result;
  for (f : fields) {
   result = assignments.findFirst[
    it.name == f
   ]
   if (result !== null) {
    return util.resolveExpression(result.expr)
   }
  }
  return "undefined"
 }
 
 def copyUtilCode(IFileSystemAccess2 fsa) {
  fsa.generateFile("util.js", "// Simple boundary check that uses axis aligned bounding boxes for overlap detection
  const touches = (obj1, obj2) => {
      return !(obj1.x > (obj2.x + (obj2.w ?? obj2.r)) ||
          (obj1.x + (obj1.w ?? obj1.r)) < obj2.x ||
          obj1.y > (obj2.y + (obj2.h ?? obj2.r)) ||
          (obj1.y + (obj1.h ?? obj1.r)) < obj2.y);
  }
  
  // ObjType enum
  const objTypes = {
      Circle: 'Circle',
      Rectangle: 'Rectangle'
  }
  
  // Draw functions
  function draw(gameObj) {
      if (Array.isArray(gameObj)) {
          gameObj.forEach(obj => drawObj(obj));
      } else {
          drawObj(gameObj);
      }
  }
  
  function drawObj(gameObj) {
      if (gameObj.visible && gameObj.visible === 1) {
          if (gameObj.type === objTypes.Rectangle) {
              drawRectangle(gameObj);
          } else if (gameObj.type === objTypes.Circle) {
              drawCircle(gameObj);
          } 
      }
  }
  
  function drawCircle(circle) {
      context.moveTo(circle.x, circle.y);
      context.beginPath();
      context.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI);
      context.fillStyle = '#6091db';
      context.fill();
      context.lineWidth = 1;
      context.strokeStyle = '#6091db';
      context.stroke();
  }
  
  function drawRectangle(rectangle) {
      context.fillStyle = 'black';
      context.fillRect(rectangle.x, rectangle.y, rectangle.w, rectangle.h);
  }
  
  
  function createDefaultGameObj(t) {
		    if (t === objTypes.Rectangle) {
		        return { x: 0, y: 0, w: 0, h: 0, visible: 1, type: t }
		    } else {
		        return { x: 0, y: 0, r: 0, xspeed: 0, yspeed: 0, visible: 1, type: t }
		    }
		}")
 }
}

class MGPLMapperUtil { 
 def mapObjType(String type) {
  switch(type) {
   case "rectangle": return "objTypes.Rectangle"
   case "circle": return "objTypes.Circle"
  }
 }
 
 def mapPropertyName(String n) {
  switch n {
   case "width": return "w"
   case "height": return "h"
   case "radius": return "r"
   case "animation_block": return "anim"
   default: return n
  }
 }
 
 def String variableName(Var v) {
  var n = v.name
  if(v.varArray !== null) {
   n += '''[«resolveExpression(v.varArray.indexExpr)»]'''
  }
  if(v.varProp !== null) {
   return n + '''.«mapPropertyName(v.varProp.extId)»'''
  }
  return n
 }
 
 def String resolveExpression(Expression e) {
  if(e === null) {
   return ""
  }
  if(e instanceof IntLiteral) {
   return String.valueOf(e.value)
  }
  if(e instanceof UnaryOperation) {
   return e.op + resolveExpression(e.right)
  }
  if(e instanceof Var) {
   return variableName(e)
  }
  if(e instanceof Operation) {
   if(e.op == "touches") {
    return '''touches(«resolveExpression(e.left)», «resolveExpression(e.right)»)'''
   }
   return '''«resolveExpression(e.left)» «e?.op» «resolveExpression(e.right)»'''
  }
 }
 
 def mapKey(String key) {
  switch(key) {
   case "leftarrow": return "ArrowLeft"
   case "rightarrow": return "ArrowRight"
   case "uparrow": return "ArrowUp"
   case "downarrow": return "ArrowDown"
  }
 }
 }